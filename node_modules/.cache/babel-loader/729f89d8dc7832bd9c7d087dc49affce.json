{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport { REHYDRATE } from './constants';\nimport isStatePlainEnough from './utils/isStatePlainEnough';\nexport default function autoRehydrate() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var stateReconciler = config.stateReconciler || defaultStateReconciler;\n  return function (next) {\n    return function (reducer, initialState, enhancer) {\n      var store = next(liftReducer(reducer), initialState, enhancer);\n      return _extends({}, store, {\n        replaceReducer: function replaceReducer(reducer) {\n          return store.replaceReducer(liftReducer(reducer));\n        }\n      });\n    };\n  };\n\n  function liftReducer(reducer) {\n    var rehydrated = false;\n    var preRehydrateActions = [];\n    return function (state, action) {\n      if (action.type !== REHYDRATE) {\n        if (config.log && !rehydrated) preRehydrateActions.push(action); // store pre-rehydrate actions for debugging\n\n        return reducer(state, action);\n      } else {\n        if (config.log && !rehydrated) logPreRehydrate(preRehydrateActions);\n        rehydrated = true;\n        var inboundState = action.payload;\n        var reducedState = reducer(state, action);\n        return stateReconciler(state, inboundState, reducedState, config.log);\n      }\n    };\n  }\n}\n\nfunction logPreRehydrate(preRehydrateActions) {\n  var concernedActions = preRehydrateActions.slice(1);\n\n  if (concernedActions.length > 0) {\n    console.log('\\n      redux-persist/autoRehydrate: %d actions were fired before rehydration completed. This can be a symptom of a race\\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\\n      after rehydration:\\n    ', concernedActions.length, concernedActions);\n  }\n}\n\nfunction defaultStateReconciler(state, inboundState, reducedState, log) {\n  var newState = _extends({}, reducedState);\n\n  Object.keys(inboundState).forEach(function (key) {\n    // if initialState does not have key, skip auto rehydration\n    if (!state.hasOwnProperty(key)) return; // if initial state is an object but inbound state is null/undefined, skip\n\n    if (_typeof(state[key]) === 'object' && !inboundState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` is falsy but initial state is an object, skipping autoRehydrate.', key);\n      return;\n    } // if reducer modifies substate, skip auto rehydration\n\n\n    if (state[key] !== reducedState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` modified, skipping autoRehydrate.', key);\n      newState[key] = reducedState[key];\n      return;\n    } // otherwise take the inboundState\n\n\n    if (isStatePlainEnough(inboundState[key]) && isStatePlainEnough(state[key])) newState[key] = _extends({}, state[key], inboundState[key]); // shallow merge\n    else newState[key] = inboundState[key]; // hard set\n\n    if (log) console.log('redux-persist/autoRehydrate: key `%s`, rehydrated to ', key, newState[key]);\n  });\n  return newState;\n}","map":null,"metadata":{},"sourceType":"module"}