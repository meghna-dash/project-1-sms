{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nvar _this = this;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar apollo_cache_inmemory_1 = require(\"apollo-cache-inmemory\");\n\nvar apollo_link_1 = require(\"apollo-link\");\n\nvar apollo_utilities_1 = require(\"apollo-utilities\");\n\nvar constants_1 = require(\"@redux-offline/redux-offline/lib/constants\");\n\nvar cache_1 = require(\"../cache\");\n\nvar utils_1 = require(\"../utils\");\n\nvar apollo_client_1 = require(\"apollo-client\");\n\nvar retry_link_1 = require(\"./retry-link\");\n\nvar logger = utils_1.rootLogger.extend('offline-link');\nvar actions = {\n  SAVE_SNAPSHOT: 'SAVE_SNAPSHOT',\n  ENQUEUE: 'ENQUEUE_OFFLINE_MUTATION',\n  COMMIT: 'COMMIT_OFFLINE_MUTATION',\n  ROLLBACK: 'ROLLBACK_OFFLINE_MUTATION',\n  SAVE_SERVER_ID: 'SAVE_SERVER_ID'\n};\nvar IS_OPTIMISTIC_KEY = typeof Symbol !== 'undefined' ? Symbol('isOptimistic') : '@@isOptimistic';\n\nexports.isOptimistic = function (obj) {\n  return typeof obj[IS_OPTIMISTIC_KEY] !== undefined ? !!obj[IS_OPTIMISTIC_KEY] : false;\n};\n\nvar OfflineLink =\n/** @class */\nfunction (_super) {\n  __extends(OfflineLink, _super);\n\n  function OfflineLink(store) {\n    var _this = _super.call(this) || this;\n\n    _this.store = store;\n    return _this;\n  }\n\n  OfflineLink.prototype.request = function (operation, forward) {\n    var _this = this;\n\n    return new apollo_link_1.Observable(function (observer) {\n      var _a;\n\n      var online = _this.store.getState().offline.online;\n\n      var operationType = apollo_utilities_1.getOperationDefinition(operation.query).operation;\n      var isMutation = operationType === 'mutation';\n      var isQuery = operationType === 'query';\n\n      if (!online && isQuery) {\n        var data = processOfflineQuery(operation, _this.store);\n        observer.next({\n          data: data\n        });\n        observer.complete();\n        return function () {\n          return null;\n        };\n      }\n\n      if (isMutation) {\n        var _b = operation.getContext(),\n            _c = _b.AASContext,\n            _d = (_c === void 0 ? {} : _c).doIt,\n            doIt = _d === void 0 ? false : _d,\n            cache = _b.cache;\n\n        if (!doIt) {\n          var _e = cache_1.METADATA_KEY,\n              enqueuedMutations = _this.store.getState()[_e].snapshot.enqueuedMutations;\n\n          if (enqueuedMutations === 0) {\n            exports.boundSaveSnapshot(_this.store, cache);\n          }\n\n          var data = enqueueMutation(operation, _this.store, observer);\n\n          if (!online) {\n            observer.next((_a = {\n              data: data\n            }, _a[IS_OPTIMISTIC_KEY] = true, _a));\n            observer.complete();\n          }\n\n          return function () {\n            return null;\n          };\n        }\n      }\n\n      var handle = forward(operation).subscribe({\n        next: observer.next.bind(observer),\n        error: observer.error.bind(observer),\n        complete: observer.complete.bind(observer)\n      });\n      return function () {\n        if (handle) handle.unsubscribe();\n      };\n    });\n  };\n\n  return OfflineLink;\n}(apollo_link_1.ApolloLink);\n\nexports.OfflineLink = OfflineLink;\n\nexports.boundSaveSnapshot = function (store, cache) {\n  return store.dispatch(saveSnapshot(cache));\n};\n\nvar saveSnapshot = function (cache) {\n  return {\n    type: actions.SAVE_SNAPSHOT,\n    payload: {\n      cache: cache\n    }\n  };\n};\n\nvar processOfflineQuery = function (operation, theStore) {\n  var _a = cache_1.NORMALIZED_CACHE_KEY,\n      _b = theStore.getState()[_a],\n      normalizedCache = _b === void 0 ? {} : _b;\n\n  var query = operation.query,\n      variables = operation.variables;\n  var cache = operation.getContext().cache;\n  var store = apollo_cache_inmemory_1.defaultNormalizedCacheFactory(normalizedCache);\n  var data = cache.storeReader.readQueryFromStore({\n    store: store,\n    query: query,\n    variables: variables\n  });\n  return data;\n};\n\nvar enqueueMutation = function (operation, theStore, observer) {\n  var mutation = operation.query,\n      variables = operation.variables;\n  var _a = operation.getContext().AASContext,\n      origOptimistic = _a.optimisticResponse,\n      update = _a.update,\n      updateQueries = _a.updateQueries,\n      refetchQueries = _a.refetchQueries,\n      fetchPolicy = _a.fetchPolicy;\n  var optimisticResponse = typeof origOptimistic === 'function' ? origOptimistic(variables) : origOptimistic;\n  setImmediate(function () {\n    var effect = {\n      optimisticResponse: optimisticResponse,\n      operation: operation,\n      update: update,\n      updateQueries: updateQueries,\n      refetchQueries: refetchQueries,\n      fetchPolicy: fetchPolicy,\n      observer: observer\n    };\n    theStore.dispatch({\n      type: actions.ENQUEUE,\n      payload: {\n        optimisticResponse: optimisticResponse\n      },\n      meta: {\n        offline: {\n          effect: effect,\n          commit: {\n            type: actions.COMMIT\n          },\n          rollback: {\n            type: actions.ROLLBACK\n          }\n        }\n      }\n    });\n  });\n  var result;\n\n  if (optimisticResponse) {\n    result = optimisticResponse;\n  } else {\n    var mutationDefinition = apollo_utilities_1.getMutationDefinition(mutation);\n    result = mutationDefinition.selectionSet.selections.reduce(function (acc, elem) {\n      acc[apollo_utilities_1.resultKeyNameFromField(elem)] = null;\n      return acc;\n    }, {});\n  }\n\n  return result;\n};\n\nvar effect = function (store, client, effect, action, callback) {\n  return __awaiter(_this, void 0, void 0, function () {\n    var _a, doIt, origOptimistic, _b, origVars, mutation, context, update, updateQueries, refetchQueries, fetchPolicy, observer, _c, idsMap, variables, optimisticResponse;\n\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          doIt = true;\n          origOptimistic = effect.optimisticResponse, _b = effect.operation, origVars = _b.variables, mutation = _b.query, context = _b.context, update = effect.update, updateQueries = effect.updateQueries, refetchQueries = effect.refetchQueries, fetchPolicy = effect.fetchPolicy, observer = effect.observer;\n          return [4\n          /*yield*/\n          , client.hydrated()];\n\n        case 1:\n          _d.sent();\n\n          _c = cache_1.METADATA_KEY, idsMap = store.getState()[_c].idsMap;\n          variables = __assign({}, exports.replaceUsingMap(__assign({}, origVars), idsMap), (_a = {}, _a[retry_link_1.SKIP_RETRY_KEY] = true, _a));\n          optimisticResponse = exports.replaceUsingMap(__assign({}, origOptimistic), idsMap);\n          return [2\n          /*return*/\n          , new Promise(function (resolve, reject) {\n            if (!client.queryManager) {\n              client.initQueryManager();\n            }\n\n            var buildOperationForLink = client.queryManager.buildOperationForLink;\n\n            var extraContext = __assign({\n              AASContext: {\n                doIt: doIt\n              }\n            }, context, {\n              optimisticResponse: optimisticResponse\n            });\n\n            var operation = buildOperationForLink.call(client.queryManager, mutation, variables, extraContext);\n            logger('Executing link', operation);\n            apollo_link_1.execute(client.link, operation).subscribe({\n              next: function (data) {\n                var _a;\n\n                boundSaveServerId(store, optimisticResponse, data.data);\n\n                var _b = store.getState(),\n                    _c = cache_1.METADATA_KEY,\n                    _d = _b[_c],\n                    idsMap = _d.idsMap,\n                    cacheSnapshot = _d.snapshot.cache,\n                    _e = _b.offline.outbox,\n                    enquededMutations = _e.slice(1); // Restore from cache snapshot\n\n\n                client.cache.restore(cacheSnapshot);\n                var dataStore = client.queryManager.dataStore;\n\n                if (fetchPolicy !== 'no-cache') {\n                  dataStore.markMutationResult({\n                    mutationId: null,\n                    result: data,\n                    document: mutation,\n                    variables: variables,\n                    updateQueries: {},\n                    update: update\n                  });\n                }\n\n                exports.boundSaveSnapshot(store, client.cache); // Apply enqueued update functions to new cache\n\n                var enqueuedActionsFilter = [exports.offlineEffectConfig.enqueueAction];\n                enquededMutations.filter(function (_a) {\n                  var type = _a.type;\n                  return enqueuedActionsFilter.indexOf(type) > -1;\n                }).forEach(function (_a) {\n                  var effect = _a.meta.offline.effect;\n\n                  var _b = effect,\n                      _c = _b.operation,\n                      _d = _c === void 0 ? {} : _c,\n                      _e = _d.variables,\n                      variables = _e === void 0 ? {} : _e,\n                      _f = _d.query,\n                      document = _f === void 0 ? null : _f,\n                      update = _b.update,\n                      origOptimisticResponse = _b.optimisticResponse,\n                      fetchPolicy = _b.fetchPolicy;\n\n                  if (typeof update !== 'function') {\n                    logger('No update function for mutation', {\n                      document: document,\n                      variables: variables\n                    });\n                    return;\n                  }\n\n                  var optimisticResponse = exports.replaceUsingMap(__assign({}, origOptimisticResponse), idsMap);\n                  var result = {\n                    data: optimisticResponse\n                  };\n\n                  if (fetchPolicy !== 'no-cache') {\n                    logger('Running update function for mutation', {\n                      document: document,\n                      variables: variables\n                    });\n                    dataStore.markMutationResult({\n                      mutationId: null,\n                      result: result,\n                      document: document,\n                      variables: variables,\n                      updateQueries: {},\n                      update: update\n                    });\n                  }\n                });\n                client.queryManager.broadcastQueries();\n                resolve({\n                  data: data\n                });\n\n                if (observer.next && !observer.closed) {\n                  observer.next(__assign({}, data, (_a = {}, _a[IS_OPTIMISTIC_KEY] = false, _a)));\n                  observer.complete();\n                } else {// throw new Error('Manually interact with cache');\n                }\n\n                if (typeof callback === 'function') {\n                  var mutationName_1 = utils_1.getOperationFieldName(mutation);\n\n                  var _f = data.context || {},\n                      _g = _f.additionalDataContext,\n                      _h = (_g === void 0 ? {} : _g).newVars,\n                      newVars_1 = _h === void 0 ? operation.variables : _h,\n                      restContext = __rest(_f, [\"additionalDataContext\"]);\n\n                  if (!Object.keys(restContext || {}).length) {\n                    delete data.context;\n                  } else {\n                    data.context = restContext;\n                  }\n\n                  apollo_utilities_1.tryFunctionOrLogError(function () {\n                    var errors = data.errors ? {\n                      mutation: mutationName_1,\n                      variables: newVars_1,\n                      error: new apollo_client_1.ApolloError({\n                        graphQLErrors: data.errors\n                      }),\n                      notified: !!observer.next\n                    } : null;\n                    var success = errors === null ? __assign({\n                      mutation: mutationName_1,\n                      variables: newVars_1\n                    }, data, {\n                      notified: !!observer.next\n                    }) : null;\n                    callback(errors, success);\n                  });\n                }\n              },\n              error: function (err) {\n                logger('Error when executing link', err);\n                reject(err);\n              }\n            });\n          })];\n      }\n    });\n  });\n};\n\nvar reducer = function (dataIdFromObject) {\n  return function (state, action) {\n    var type = action.type,\n        payload = action.payload;\n\n    switch (type) {\n      case constants_1.PERSIST_REHYDRATE:\n        var _a = cache_1.METADATA_KEY,\n            rehydratedState = payload[_a];\n        return rehydratedState || state;\n\n      default:\n        var _b = state || {},\n            _c = _b.idsMap,\n            origIdsMap = _c === void 0 ? {} : _c,\n            _d = _b.snapshot,\n            origSnapshot = _d === void 0 ? {} : _d,\n            restState = __rest(_b, [\"idsMap\", \"snapshot\"]);\n\n        var snapshot = snapshotReducer(origSnapshot, action);\n        var idsMap = idsMapReducer(origIdsMap, __assign({}, action, {\n          remainingMutations: snapshot.enqueuedMutations\n        }), dataIdFromObject);\n        return __assign({}, restState, {\n          snapshot: snapshot,\n          idsMap: idsMap\n        });\n    }\n  };\n};\n\nvar snapshotReducer = function (state, action) {\n  var enqueuedMutations = enqueuedMutationsReducer(state && state.enqueuedMutations, action);\n  var cache = cacheSnapshotReducer(state && state.cache, __assign({}, action, {\n    enqueuedMutations: enqueuedMutations\n  }));\n  return {\n    enqueuedMutations: enqueuedMutations,\n    cache: cache\n  };\n};\n\nvar enqueuedMutationsReducer = function (state, action) {\n  if (state === void 0) {\n    state = 0;\n  }\n\n  var type = action.type;\n\n  switch (type) {\n    case actions.ENQUEUE:\n      return state + 1;\n\n    case actions.COMMIT:\n    case actions.ROLLBACK:\n      return state - 1;\n\n    default:\n      return state;\n  }\n};\n\nvar cacheSnapshotReducer = function (state, action) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  var type = action.type,\n      payload = action.payload;\n\n  switch (type) {\n    case actions.SAVE_SNAPSHOT:\n      var cache = payload.cache;\n\n      var cacheContents = __assign({}, cache.extract(false));\n\n      return cacheContents;\n\n    default:\n      return state;\n  }\n};\n\nvar boundSaveServerId = function (store, optimisticResponse, data) {\n  return store.dispatch(saveServerId(optimisticResponse, data));\n};\n\nvar saveServerId = function (optimisticResponse, data) {\n  return {\n    type: actions.SAVE_SERVER_ID,\n    payload: {\n      data: data,\n      optimisticResponse: optimisticResponse\n    }\n  };\n};\n\nvar idsMapReducer = function (state, action, dataIdFromObject) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  var type = action.type,\n      _a = action.payload,\n      payload = _a === void 0 ? {} : _a;\n  var optimisticResponse = payload.optimisticResponse;\n\n  switch (type) {\n    case actions.ENQUEUE:\n      var ids = exports.getIds(dataIdFromObject, optimisticResponse);\n      var entries = Object.values(ids).reduce(function (acc, id) {\n        return acc[id] = null, acc;\n      }, {});\n      return __assign({}, state, entries);\n\n    case actions.COMMIT:\n      var remainingMutations = action.remainingMutations; // Clear ids map on last mutation\n\n      return remainingMutations ? state : {};\n\n    case actions.SAVE_SERVER_ID:\n      var data = payload.data;\n      var oldIds = exports.getIds(dataIdFromObject, optimisticResponse);\n      var newIds = exports.getIds(dataIdFromObject, data);\n      var mapped = mapIds(oldIds, newIds);\n      return __assign({}, state, mapped);\n\n    default:\n      return state;\n  }\n};\n\nvar discard = function (callback, error, action, retries) {\n  var discardResult = _discard(error, action, retries);\n\n  if (discardResult) {\n    // Call global error callback and observer\n    var observer = action.meta.offline.effect.observer;\n\n    if (observer && !observer.closed) {\n      observer.error(error);\n    }\n\n    if (typeof callback === 'function') {\n      apollo_utilities_1.tryFunctionOrLogError(function () {\n        callback({\n          error: error\n        }, null);\n      });\n    }\n  }\n\n  return discardResult;\n};\n\nvar _discard = function (error, action, retries) {\n  var _a = error.graphQLErrors,\n      graphQLErrors = _a === void 0 ? [] : _a;\n\n  if (graphQLErrors.length) {\n    logger('Discarding action.', action, graphQLErrors);\n    return true;\n  } else {\n    var _b = error.networkError,\n        _c = (_b === void 0 ? {\n      graphQLErrors: []\n    } : _b).graphQLErrors,\n        graphQLErrors_1 = _c === void 0 ? [] : _c;\n    var appSyncClientError = graphQLErrors_1.find(function (err) {\n      return err.errorType && err.errorType.startsWith('AWSAppSyncClient:');\n    });\n\n    if (appSyncClientError) {\n      logger('Discarding action.', action, appSyncClientError);\n      return true;\n    }\n  }\n\n  return error.permanent || retries > 10;\n}; //#region utils\n\n\nexports.replaceUsingMap = function (obj, map) {\n  if (map === void 0) {\n    map = {};\n  }\n\n  if (!obj || !map) {\n    return obj;\n  }\n\n  var newVal = map[obj];\n\n  if (newVal) {\n    obj = newVal;\n    return obj;\n  }\n\n  if (typeof obj === 'object') {\n    Object.keys(obj).forEach(function (key) {\n      var val = obj[key];\n\n      if (Array.isArray(val)) {\n        obj[key] = val.map(function (v, i) {\n          return exports.replaceUsingMap(v, map);\n        });\n      } else if (typeof val === 'object') {\n        obj[key] = exports.replaceUsingMap(val, map);\n      } else {\n        var newVal_1 = map[val];\n\n        if (newVal_1) {\n          obj[key] = newVal_1;\n        }\n      }\n    });\n  }\n\n  return obj;\n};\n\nexports.getIds = function (dataIdFromObject, obj, path, acc) {\n  if (path === void 0) {\n    path = '';\n  }\n\n  if (acc === void 0) {\n    acc = {};\n  }\n\n  if (!obj) {\n    return acc;\n  }\n\n  if (typeof obj === 'object') {\n    var dataId = dataIdFromObject(obj);\n\n    if (dataId) {\n      var _a = dataId.match(/(.+:)?(.+)/) || [],\n          _b = _a[2],\n          id = _b === void 0 ? null : _b;\n\n      if (utils_1.isUuid(dataId)) {\n        acc[path] = id;\n      }\n    }\n\n    Object.keys(obj).forEach(function (key) {\n      var val = obj[key];\n\n      if (Array.isArray(val)) {\n        val.forEach(function (v, i) {\n          return exports.getIds(dataIdFromObject, v, path + \".\" + key + \"[\" + i + \"]\", acc);\n        });\n      } else if (typeof val === 'object') {\n        exports.getIds(dataIdFromObject, val, \"\" + path + (path && '.') + key, acc);\n      }\n    });\n  }\n\n  return exports.getIds(dataIdFromObject, null, path, acc);\n};\n\nvar intersectingKeys = function (obj1, obj2) {\n  if (obj1 === void 0) {\n    obj1 = {};\n  }\n\n  if (obj2 === void 0) {\n    obj2 = {};\n  }\n\n  var keys1 = Object.keys(obj1);\n  var keys2 = Object.keys(obj2);\n  return keys1.filter(function (k) {\n    return keys2.indexOf(k) !== -1;\n  });\n};\n\nvar mapIds = function (obj1, obj2) {\n  return intersectingKeys(obj1, obj2).reduce(function (acc, k) {\n    return acc[obj1[k]] = obj2[k], acc;\n  }, {});\n}; //#endregion\n\n\nexports.offlineEffectConfig = {\n  enqueueAction: actions.ENQUEUE,\n  effect: effect,\n  discard: discard,\n  reducer: reducer\n};","map":null,"metadata":{},"sourceType":"script"}