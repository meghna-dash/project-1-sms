{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar uuid_1 = require(\"uuid\");\n\nvar apollo_utilities_1 = require(\"apollo-utilities\");\n\nvar client_1 = require(\"../client\");\n\nvar link_1 = require(\"../link\");\n\nvar utils_1 = require(\"../utils\");\n\nvar logger = utils_1.rootLogger.extend('offline-helper');\nvar CacheOperationTypes;\n\n(function (CacheOperationTypes) {\n  CacheOperationTypes[\"AUTO\"] = \"auto\";\n  CacheOperationTypes[\"ADD\"] = \"add\";\n  CacheOperationTypes[\"REMOVE\"] = \"remove\";\n  CacheOperationTypes[\"UPDATE\"] = \"update\";\n})(CacheOperationTypes = exports.CacheOperationTypes || (exports.CacheOperationTypes = {}));\n\n;\nvar prefixesForRemove = ['delete', 'deleted', 'discard', 'discarded', 'erase', 'erased', 'remove', 'removed'];\nvar prefixesForUpdate = ['update', 'updated', 'upsert', 'upserted', 'edit', 'edited', 'modify', 'modified'];\nvar prefixesForAdd = ['create', 'created', 'put', 'set', 'add', 'added', 'new', 'insert', 'inserted'];\n\nexports.getOpTypeFromOperationName = function (opName) {\n  if (opName === void 0) {\n    opName = '';\n  } // Note: we do a toLowerCase() and startsWith() to avoid ambiguity with operations like \"RemoveAddendum\"\n\n\n  var comparator = function (prefix) {\n    return opName.toLowerCase().startsWith(prefix) || opName.toLowerCase().startsWith(\"on\" + prefix);\n  };\n\n  var result = CacheOperationTypes.AUTO;\n  [[prefixesForAdd, CacheOperationTypes.ADD], [prefixesForRemove, CacheOperationTypes.REMOVE], [prefixesForUpdate, CacheOperationTypes.UPDATE]].forEach(function (_a) {\n    var prefix = _a[0],\n        type = _a[1];\n\n    if (prefix.some(comparator)) {\n      result = type;\n      return;\n    }\n  });\n  return result;\n};\n/**\n * Builds a SubscribeToMoreOptions object ready to be used by Apollo's subscribeToMore() to automatically update the query result in the\n * cache according to the cacheUpdateQuery parameter\n *\n * @param subscriptionQuery The GraphQL subscription DocumentNode or CacheUpdateQuery\n * @param cacheUpdateQuery The query for which the result needs to be updated\n * @param idField\n * @param operationType\n */\n\n\nvar buildSubscription = function (subscriptionQuery, cacheUpdateQuery, idField, operationType) {\n  var document = subscriptionQuery && subscriptionQuery.query || subscriptionQuery;\n  var variables = subscriptionQuery && subscriptionQuery.variables || {};\n  var query = cacheUpdateQuery && cacheUpdateQuery.query || cacheUpdateQuery;\n  var queryField = utils_1.getOperationFieldName(query);\n  return {\n    document: document,\n    variables: variables,\n    updateQuery: function (prev, _a) {\n      var data = _a.subscriptionData.data;\n\n      var _b;\n\n      var subField = Object.keys(data)[0];\n      var _c = subField,\n          mutadedItem = data[_c];\n      var optype = operationType || exports.getOpTypeFromOperationName(subField);\n      var updater = exports.getUpdater(optype, idField);\n      var updatedOpResult;\n      var result;\n      var path = findArrayInObject(prev);\n\n      if (path) {\n        var arr = getValueByPath(prev, path).slice();\n        updatedOpResult = updater(arr, mutadedItem);\n      } else {\n        updatedOpResult = updater(prev, mutadedItem);\n      }\n\n      if (!path || path.length === 0) {\n        result = updatedOpResult;\n      } else {\n        var cloned = apollo_utilities_1.cloneDeep(prev);\n        setValueByPath(cloned, path, updatedOpResult);\n        result = cloned[queryField];\n      }\n\n      return _b = {}, _b[queryField] = result, _b;\n    }\n  };\n};\n\nexports.buildSubscription = buildSubscription;\n\nexports.getUpdater = function (opType, idField) {\n  if (idField === void 0) {\n    idField = 'id';\n  }\n\n  var updater;\n\n  switch (opType) {\n    case CacheOperationTypes.ADD:\n      updater = function (currentValue, newItem) {\n        if (Array.isArray(currentValue)) {\n          return !newItem ? currentValue.slice() : currentValue.filter(function (item) {\n            return item[idField] !== newItem[idField];\n          }).concat([newItem]);\n        } else {\n          return newItem;\n        }\n      };\n\n      break;\n\n    case CacheOperationTypes.UPDATE:\n      updater = function (currentValue, newItem) {\n        if (Array.isArray(currentValue)) {\n          return !newItem ? currentValue.slice() : currentValue.map(function (item) {\n            return item[idField] === newItem[idField] ? newItem : item;\n          });\n        } else {\n          return newItem;\n        }\n      };\n\n      break;\n\n    case CacheOperationTypes.REMOVE:\n      updater = function (currentValue, newItem) {\n        if (Array.isArray(currentValue)) {\n          return !newItem ? currentValue.slice() : currentValue.filter(function (item) {\n            return item[idField] !== newItem[idField];\n          });\n        } else {\n          return null;\n        }\n      };\n\n      break;\n\n    default:\n      updater = function (currentValue) {\n        return currentValue;\n      };\n\n  }\n\n  return updater;\n};\n\nvar getOpTypeQueriesMap = function (cacheUpdateQuery, variables) {\n  var _a;\n\n  var cacheUpdateQueryVal = typeof cacheUpdateQuery === 'function' ? cacheUpdateQuery(variables) : cacheUpdateQuery || {};\n  var opTypeQueriesMap = cacheUpdateQueryVal;\n\n  if (isDocument(cacheUpdateQueryVal) || isDocument(cacheUpdateQueryVal.query) || Array.isArray(cacheUpdateQuery)) {\n    opTypeQueriesMap = (_a = {}, _a[CacheOperationTypes.AUTO] = [].concat(cacheUpdateQueryVal), _a);\n  }\n\n  return opTypeQueriesMap;\n};\n\nvar getEvaluatedOp = function (opType, mutationField, operationType) {\n  var evaluatedOP = opType === CacheOperationTypes.AUTO ? operationType || exports.getOpTypeFromOperationName(mutationField) : opType;\n  return evaluatedOP;\n};\n\nvar findArrayInObject = function (obj, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  if (Array.isArray(obj)) {\n    return path;\n  }\n\n  if (!isObject(obj)) {\n    return undefined;\n  }\n\n  var result;\n  Object.keys(obj).some(function (key) {\n    var newPath = findArrayInObject(obj[key], path.concat(key));\n\n    if (newPath) {\n      result = newPath;\n      return true;\n    }\n\n    return false;\n  });\n  return result;\n};\n\nvar getValueByPath = function (obj, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  return path.reduce(function (acc, elem) {\n    var val = acc && acc[elem];\n\n    if (val) {\n      return val;\n    }\n\n    return null;\n  }, obj);\n};\n\nvar setValueByPath = function (obj, path, value) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  return path.reduce(function (acc, elem, i, arr) {\n    if (arr.length - 1 === i) {\n      acc[elem] = value;\n      return obj;\n    }\n\n    return acc[elem];\n  }, obj);\n};\n\nvar isDocument = function (doc) {\n  return !!doc && doc.kind === 'Document';\n}; // make sure that the object is of type object and is not null.\n\n\nvar isObject = function (object) {\n  return object != null && typeof object === 'object';\n};\n/**\n * Builds a MutationOptions object ready to be used by the ApolloClient to automatically update the cache according to the cacheUpdateQuery\n * parameter\n *\n * @param client An ApolloClient instance\n * @param mutation DocumentNode for the muation\n * @param variables An object with the mutation variables\n * @param cacheUpdateQuery The queries to update in the cache\n * @param typename __typename from your schema\n * @param idField The name of the field with the ID\n * @param operationType Override for the operation type\n *\n * @returns Mutation options to be used by the ApolloClient\n */\n\n\nvar buildMutation = function (client, mutation, variablesInfo, cacheUpdateQuery, typename, idField, operationType) {\n  if (idField === void 0) {\n    idField = 'id';\n  }\n\n  var _a, _b, _c;\n\n  var isVariablesInfo = typeof variablesInfo.variables === 'object';\n  var variables = isVariablesInfo ? variablesInfo.variables : variablesInfo;\n  var hasInputType = Object.keys(variables).length === 1 && typeof variables.input === 'object';\n  var inputTypeVersionField = isVariablesInfo && variablesInfo.inputType.definitions[0].fields.find(function (f) {\n    return ['version', 'expectedVersion'].find(function (n) {\n      return n === f.name.value;\n    }) && f.type.name.value === 'Int';\n  });\n  var useVersioning = hasInputType ? !!inputTypeVersionField : true;\n  var opTypeQueriesMap = getOpTypeQueriesMap(cacheUpdateQuery, variables);\n\n  var _d = idField || 'id',\n      idCustomField = (hasInputType ? variables.input : variables)[_d];\n\n  var comparator = function (elem) {\n    return elem[idField] === idCustomField;\n  };\n\n  var version = 0;\n\n  for (var opType in opTypeQueriesMap) {\n    var queries = [].concat(opTypeQueriesMap[opType]);\n    queries.forEach(function (queryEntry) {\n      var query = queryEntry && queryEntry.query || queryEntry;\n      var queryVars = queryEntry && queryEntry.variables || {};\n      var queryField = utils_1.getOperationFieldName(query);\n      var result;\n      var cachedItem;\n\n      try {\n        var _a = queryField,\n            queryRead = client.readQuery({\n          query: query,\n          variables: queryVars\n        })[_a];\n\n        result = queryRead;\n      } catch (err) {\n        logger('Skipping query', query, err.message);\n        return;\n      }\n\n      var path = findArrayInObject(result);\n\n      if (path) {\n        var arr = getValueByPath(result, path).slice();\n        cachedItem = arr.find(comparator);\n      } else {\n        cachedItem = result;\n      }\n\n      if (cachedItem) {\n        version = Math.max(version, cachedItem.version);\n      }\n    });\n  }\n\n  ;\n  var mutationField = utils_1.getOperationFieldName(mutation);\n  var cache = client && client instanceof client_1.default && client.isOfflineEnabled() && client.cache;\n  var versionFieldName = inputTypeVersionField ? inputTypeVersionField.name.value : '';\n  return {\n    mutation: mutation,\n    variables: hasInputType ? {\n      input: __assign({}, useVersioning && (_a = {}, _a[versionFieldName] = version, _a), variables.input)\n    } : __assign({\n      version: version,\n      expectedVersion: version\n    }, variables),\n    optimisticResponse: typename ? (_b = {\n      __typename: \"Mutation\"\n    }, _b[mutationField] = __assign((_c = {\n      __typename: typename\n    }, _c[idField] = (hasInputType ? variables.input : variables)[idField] || uuid_1.v4(), _c), hasInputType ? variables.input : variables, {\n      version: version + 1\n    }), _b) : null,\n    update: function (proxy, _a) {\n      var _b = mutationField,\n          mutatedItem = _a.data[_b];\n\n      var _loop_1 = function (opType) {\n        var queries = [].concat(opTypeQueriesMap[opType]);\n        var updaterFn = exports.getUpdater(getEvaluatedOp(opType, mutationField, operationType), idField);\n        queries.forEach(function (queryEntry) {\n          var query = queryEntry && queryEntry.query || queryEntry;\n          var queryField = utils_1.getOperationFieldName(query);\n          var queryVars = queryEntry && queryEntry.variables || {};\n\n          if (cache) {\n            queryVars = link_1.replaceUsingMap(__assign({}, queryVars), cache.getIdsMap());\n          }\n\n          var data;\n          var updatedOpResult;\n\n          try {\n            data = proxy.readQuery({\n              query: query,\n              variables: queryVars\n            });\n          } catch (err) {\n            logger('Skipping query', query, err.message);\n            return;\n          }\n\n          var opResultCachedValue = data[queryField];\n          var path = findArrayInObject(opResultCachedValue);\n\n          if (path) {\n            var arr = getValueByPath(opResultCachedValue, path).slice();\n            updatedOpResult = updaterFn(arr, mutatedItem);\n          } else {\n            updatedOpResult = updaterFn(opResultCachedValue, mutatedItem);\n          }\n\n          if (!path || path.length === 0) {\n            data[queryField] = updatedOpResult;\n          } else {\n            setValueByPath(data[queryField], path, updatedOpResult);\n          }\n\n          proxy.writeQuery({\n            query: query,\n            variables: queryVars,\n            data: data\n          });\n        });\n      };\n\n      for (var opType in opTypeQueriesMap) {\n        _loop_1(opType);\n      }\n    }\n  };\n};\n\nexports.buildMutation = buildMutation;","map":null,"metadata":{},"sourceType":"script"}