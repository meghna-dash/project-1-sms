{"ast":null,"code":"export function buildDelayFunction(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.initial,\n      initial = _c === void 0 ? 300 : _c,\n      _d = _b.max,\n      max = _d === void 0 ? Infinity : _d,\n      _e = _b.jitter,\n      jitter = _e === void 0 ? true : _e;\n\n  var baseDelay;\n\n  if (jitter) {\n    // If we're jittering, baseDelay is half of the maximum delay for that\n    // attempt (and is, on average, the delay we will encounter).\n    baseDelay = initial;\n  } else {\n    // If we're not jittering, adjust baseDelay so that the first attempt\n    // lines up with initialDelay, for everyone's sanity.\n    baseDelay = initial / 2;\n  }\n\n  return function delayFunction(count) {\n    var delay = Math.min(max, baseDelay * Math.pow(2, count));\n\n    if (jitter) {\n      // We opt for a full jitter approach for a mostly uniform distribution,\n      // but bound it within initialDelay and delay for everyone's sanity.\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}